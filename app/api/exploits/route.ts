/**
 * Exploits Database API Route
 * 
 * Fetches historical exploit data from DeFiLlama Hacks API
 * and provides filtering/search capabilities.
 * 
 * Data Source: https://api.llama.fi/hacks (Free, comprehensive)
 * 
 * GET /api/exploits
 * Query params:
 *   - chain: Filter by chain (e.g., "Solana", "Ethereum")
 *   - minAmount: Minimum amount lost (in USD)
 *   - technique: Filter by technique
 *   - limit: Number of results (default 100)
 *   - search: Search by protocol name
 */

import { NextRequest, NextResponse } from 'next/server';

// Types for exploit data
export interface Exploit {
    id: string;
    date: string;           // ISO date string
    timestamp: number;      // Unix timestamp
    name: string;           // Protocol name
    amount: number | null;  // Amount lost in USD
    chain: string[];        // Chains affected
    technique: string | null;
    classification: string | null;
    targetType: string | null;
    source: string | null;  // Source URL
    language: string | null;
    bridgeHack: boolean;
    returnedFunds: number | null;
}

export interface ExploitsResponse {
    exploits: Exploit[];
    total: number;
    totalLost: number;
    chains: string[];
    techniques: string[];
    lastUpdated: string;
}

// Cache for exploit data (5 minute TTL)
let cachedData: {
    exploits: Exploit[];
    timestamp: number;
} | null = null;
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Fetch exploits from DeFiLlama API
 */
async function fetchExploits(): Promise<Exploit[]> {
    // Check cache
    if (cachedData && Date.now() - cachedData.timestamp < CACHE_TTL) {
        console.log('[Exploits API] Using cached data');
        return cachedData.exploits;
    }

    console.log('[Exploits API] Fetching from DeFiLlama...');

    try {
        const response = await fetch('https://api.llama.fi/hacks', {
            next: { revalidate: 300 }, // Next.js cache for 5 min
        });

        if (!response.ok) {
            console.error('[Exploits API] DeFiLlama API error:', response.status);
            throw new Error('Failed to fetch from DeFiLlama');
        }

        const rawData = await response.json();

        // Transform data
        const exploits: Exploit[] = rawData.map((item: {
            date: number;
            name: string;
            amount: number | null;
            chain: string[] | null;
            technique: string | null;
            classification: string | null;
            targetType: string | null;
            source: string | null;
            language: string | null;
            bridgeHack: boolean;
            returnedFunds: number | null;
        }, index: number) => ({
            id: `exploit-${index}-${item.date}`,
            date: new Date(item.date * 1000).toISOString(),
            timestamp: item.date,
            name: item.name?.trim() || 'Unknown',
            amount: item.amount,
            chain: item.chain || [],
            technique: item.technique,
            classification: item.classification,
            targetType: item.targetType,
            source: item.source,
            language: item.language,
            bridgeHack: item.bridgeHack || false,
            returnedFunds: item.returnedFunds,
        }));

        // Sort by date (newest first)
        exploits.sort((a, b) => b.timestamp - a.timestamp);

        // Update cache
        cachedData = {
            exploits,
            timestamp: Date.now(),
        };

        console.log(`[Exploits API] Fetched ${exploits.length} exploits`);
        return exploits;
    } catch (error) {
        console.error('[Exploits API] Error:', error);
        // Return cached data if available, even if expired
        if (cachedData) {
            return cachedData.exploits;
        }
        throw error;
    }
}

/**
 * GET handler
 */
export async function GET(request: NextRequest): Promise<NextResponse<ExploitsResponse | { error: string }>> {
    try {
        const { searchParams } = new URL(request.url);

        // Parse query parameters
        const chain = searchParams.get('chain')?.toLowerCase();
        const minAmount = parseInt(searchParams.get('minAmount') || '0');
        const technique = searchParams.get('technique')?.toLowerCase();
        const search = searchParams.get('search')?.toLowerCase();
        const limit = parseInt(searchParams.get('limit') || '100');
        const solanaOnly = searchParams.get('solanaOnly') === 'true';

        // Fetch all exploits
        let exploits = await fetchExploits();

        // Apply filters
        if (chain) {
            exploits = exploits.filter(e =>
                e.chain.some(c => c.toLowerCase().includes(chain))
            );
        }

        if (solanaOnly) {
            exploits = exploits.filter(e =>
                e.chain.some(c => c.toLowerCase() === 'solana')
            );
        }

        if (minAmount > 0) {
            exploits = exploits.filter(e =>
                e.amount !== null && e.amount >= minAmount
            );
        }

        if (technique) {
            exploits = exploits.filter(e =>
                e.technique?.toLowerCase().includes(technique)
            );
        }

        if (search) {
            exploits = exploits.filter(e =>
                e.name.toLowerCase().includes(search) ||
                e.technique?.toLowerCase().includes(search) ||
                e.classification?.toLowerCase().includes(search)
            );
        }

        // Calculate totals before limiting
        const totalLost = exploits.reduce((sum, e) => sum + (e.amount || 0), 0);
        const total = exploits.length;

        // Get unique chains and techniques for filters
        const allExploits = cachedData?.exploits || exploits;
        const chains = [...new Set(allExploits.flatMap(e => e.chain))].filter(Boolean).sort();
        const techniques = [...new Set(allExploits.map(e => e.technique).filter(Boolean) as string[])].sort();

        // Apply limit
        exploits = exploits.slice(0, limit);

        return NextResponse.json({
            exploits,
            total,
            totalLost,
            chains,
            techniques,
            lastUpdated: new Date().toISOString(),
        });
    } catch (error) {
        console.error('[Exploits API] Request error:', error);
        return NextResponse.json(
            { error: 'Failed to fetch exploit data' },
            { status: 500 }
        );
    }
}
